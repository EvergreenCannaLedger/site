---
title: "State of the WA Auditor Office on Cannabis Traceability"
subtitle: "How Washington‚Äôs Cannabis Market Found Its Balance Between Innovation and Saturation (2021‚Äì2025)"
description: "Using data to fact check WA State Auditor"
date: "2025-06-05"
categories: [CCRS, State Auditor, Traceability]
format: html
fig-width: 8
fig-height: 5
toc: true
editor:
  markdown:
    wrap: 72
---

Exploring how CCRS data addresses (or fails to address) concerns raised by the Washington State Auditor in an October 22, 2024 [press release](https://sao.wa.gov/the-audit-connection-blog/states-cannabis-tracking-system-falls-short-long-sought-goals-audit-finds).
  

The data covers the entire CCRS program - Dec 2021 to present day.  

The concerns in the press release were: 

+ Lack of seed-to-sale traceability

+ Inflated or inconsistent reported sales

+ Lack of real-time tracking

+ Data integrity and accessibility for licensees

TECL demonstrates below how to use CCRS to track quality, outliers, non-conformers, and more to address total traceability.  Everyone has concerns about regulated weed crossing the border, and tracking the above KPIs can point regulators to license holders to validate entries. 

Due to the severity of the matter involving government cannabis regulators and the Office of the Washington State Auditor, we share our SQL queries to view the data in tables and graphs. 
```{r setup, message=FALSE, warning=FALSE, echo=FALSE, include=FALSE}

library(tidyverse)
library(DBI)
library(dplyr)
library(lubridate)
library(plotly)
library(arrow)
library(duckdb)
library(fs)
library(glue)
library(kableExtra)
library(scales)

#Clean Slate Function
unregister_all_arrow <- function(con) {
  walk(duckdb_list_arrow(con), ~ {
    duckdb_unregister_arrow(con, .x)
    message("üßπ Unregistered: ", .x)
  })
}


# set paths
base_dir <- "C:/Users/theob/OneDrive/Documents/evergreen-canna-ledger/arrow"
duckdb_path <- file.path(dirname(base_dir), "duckdb_master.duckdb")

# Connect to DuckDB
con <- dbConnect(duckdb::duckdb(), dbdir = duckdb_path, read_only = FALSE)

# Register base files (historical master data)
register_master_parquet <- function(con, base_dir) {
  master_files <- list.files(base_dir, pattern = "\\.parquet$", full.names = TRUE)

  table_names <- tools::file_path_sans_ext(basename(master_files)) %>%
    str_replace_all("([a-z])([A-Z])", "\\1_\\2") %>%
    str_replace_all("[^[:alnum:]_]", "_") %>%
    str_to_lower()

  walk2(table_names, master_files, ~ {
    table_name <- paste0(.x, "_master")
    if (table_name %in% duckdb_list_arrow(con)) {
      duckdb_unregister_arrow(con, table_name)
      message("üßπ Unregistered master: ", table_name)
    }

    dataset <- arrow::open_dataset(.y)
    duckdb_register_arrow(con, table_name, dataset)
    message("üì¶ Registered master: ", table_name)
  })
}

# Register master files safely
register_master_parquet(con, base_dir)

#Register new monthly folders (already done before, but included here for completeness)
register_monthly_parquet_to_duckdb <- function(db_path, parquet_folders) {
  con <- dbConnect(duckdb::duckdb(), dbdir = db_path, read_only = FALSE)

  for (folder in parquet_folders) {
    month_label <- basename(folder)
    parquet_files <- list.files(folder, pattern = "\\.parquet$", full.names = TRUE)

    table_names <- tools::file_path_sans_ext(basename(parquet_files)) %>%
      str_replace_all("([a-z])([A-Z])", "\\1_\\2") %>%
      str_replace_all("[^[:alnum:]_]", "_") %>%
      str_to_lower()

    walk2(table_names, parquet_files, ~ {
      table_name <- paste0(.x, "_", month_label)
      if (table_name %in% duckdb_list_arrow(con)) {
        duckdb_unregister_arrow(con, table_name)
        message("üßπ Unregistered: ", table_name)
      }

      dataset <- arrow::open_dataset(.y)
      duckdb_register_arrow(con, table_name, dataset)
      message("üìå Registered monthly: ", table_name)
    })
  }

  return(con)
}
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}

#Register monthly files safely
monthly_dirs <- dir_ls(base_dir, recurse = FALSE, type = "directory")
monthly_arrow_dirs <- monthly_dirs[str_detect(monthly_dirs, "arrow_[a-z]+2025")]
register_monthly_parquet_to_duckdb(duckdb_path, monthly_arrow_dirs)

# Create unified views (master + monthly)
create_combined_view <- function(con, base_name) {
  tables <- duckdb_list_arrow(con)
  relevant_tables <- tables[str_detect(tables, paste0("^", base_name, "_(master|arrow_.*2025)"))]

  if (length(relevant_tables) == 0) {
    message("‚ö†Ô∏è No tables found for ", base_name)
    return(invisible(NULL))
  }

  # Get Arrow schema columns for each table
  column_lists <- map(relevant_tables, ~ {
  cols <- names(dbGetQuery(con, glue::glue("SELECT * FROM \"{.x}\" LIMIT 0")))
  tibble(table = .x, column = cols)
}) %>% bind_rows()

  # Keep only columns common to all tables
  common_columns <- column_lists %>%
    group_by(column) %>%
    summarise(n_tables = n_distinct(table), .groups = "drop") %>%
    filter(n_tables == length(relevant_tables)) %>%
    pull(column)

  if (length(common_columns) == 0) {
    message("‚ùå No common columns found across tables for ", base_name)
    return(invisible(NULL))
  }

  # Logged dropped columns
  all_cols <- column_lists %>% distinct(column)
  dropped_cols <- setdiff(all_cols$column, common_columns)
  if (length(dropped_cols)) {
    message("‚ö†Ô∏è Dropping columns not in all tables for ", base_name, ": ", paste(dropped_cols, collapse = ", "))
  }

  # Build UNION ALL
  union_parts <- map_chr(relevant_tables, ~ {
    cols <- paste(common_columns, collapse = ", ")
    glue::glue("SELECT {cols} FROM \"{.x}\"")  # quote in case of special chars
  })

  union_sql <- glue::glue("
    CREATE OR REPLACE VIEW {base_name}_all AS
    {paste(union_parts, collapse = '\nUNION ALL\n')}
  ")

  dbExecute(con, union_sql)
  message("‚úÖ Created view: ", base_name, "_all with ", length(relevant_tables), " parts.")
}

views_to_create <- c(
  "sales_detail", "sale_header", "inventory", "product", "lab_result",
  "areas", "licensee", "plant", "strains", "contacts"
)

walk(views_to_create, ~ create_combined_view(con, .x))

```

## Number of Licensees (2021-2025)
```{r, echo=TRUE}

monthly_sales <- dbGetQuery(con, "
WITH base AS (
SELECT
sh.LicenseeId,
DATE_TRUNC('month', CAST(sh.SaleDate AS DATE)) AS Month,
CAST(sd.Quantity AS DOUBLE) * CAST(sd.UnitPrice AS DOUBLE) +
CAST(sd.SalesTax AS DOUBLE) + CAST(sd.OtherTax AS DOUBLE) AS Revenue
FROM sales_detail_all sd
JOIN sale_header_all sh ON sd.SaleHeaderId = sh.SaleHeaderId
WHERE DATE(CAST(sh.SaleDate AS DATE)) BETWEEN '2021-12-01' AND '2025-08-31'
AND CAST(sd.UnitPrice AS DOUBLE) < 200
),
grouped AS (
SELECT
Month,
LicenseeId,
SUM(Revenue) AS TotalRevenue
FROM base
GROUP BY Month, LicenseeId
),
licensee_counts AS (
SELECT
Month,
COUNT(DISTINCT LicenseeId) AS LicenseeCount
FROM grouped
GROUP BY Month
ORDER BY Month
)
SELECT * FROM licensee_counts
")
```

```{r, echo=FALSE, include=TRUE}
# Convert Month to date type

monthly_sales <- monthly_sales %>%
mutate(Month = as.Date(Month))

# Plotly bar chart
plot_ly(
data = monthly_sales,
x = ~Month,
y = ~LicenseeCount,
type = "bar",
marker = list(color = "#2C7BB6")
) %>%
layout(
title = "Number of Licensees Reporting Monthly (Dec 2021 - Aug 2025)",
xaxis = list(title = "Month"),
yaxis = list(title = "Licensee Count"),
hovermode = "x unified"
)

```
##  Seed-to-Sale Visibility
**Partial Traceability ‚Äì Example Joins from Plant ‚Üí Inventory ‚Üí Sale**
```{r, echo=TRUE}

plant_to_sale <- dbGetQuery(con, "
  SELECT
    p.ExternalIdentifier AS PlantID,
    i.InventoryId,
    s.SaleDetailId,
    p.HarvestDate,
    i.CreatedDate AS InventoryDate,
    s.CreatedDate AS SaleDate
  FROM plant_all p
  LEFT JOIN inventory_all i 
    ON p.ExternalIdentifier = i.ExternalIdentifier
  LEFT JOIN sales_detail_all s 
    ON i.InventoryId = s.InventoryId
  WHERE s.CreatedDate IS NOT NULL
  LIMIT 50
")
```

```{r, echo=FALSE, include=TRUE}

plant_to_sale %>%
kbl() %>%
kable_styling(full_width = FALSE)


```


## Sales Integrity
**CCRS vs WA DOR Sales Comparison**
```{r, echo=TRUE}

ccrs_sales <- dbGetQuery(con, "
  SELECT
    strftime(TRY_CAST(h.CreatedDate AS TIMESTAMP), '%Y') AS Year,

    ROUND(
      SUM(
        TRY_CAST(d.UnitPrice AS DOUBLE) * 
        TRY_CAST(d.Quantity AS DOUBLE)
      ), 2
    ) AS CCRS_Sales,

    ROUND(
      SUM(
        (TRY_CAST(d.UnitPrice AS DOUBLE) * TRY_CAST(d.Quantity AS DOUBLE)) +
        COALESCE(TRY_CAST(d.SalesTax AS DOUBLE), 0)
      ), 2
    ) AS CCRS_Sales_With_Tax

  FROM sales_detail_all d
  JOIN sale_header_all h 
    ON d.SaleHeaderId = h.SaleHeaderId

  WHERE 
    TRY_CAST(h.CreatedDate AS TIMESTAMP) IS NOT NULL AND
    TRY_CAST(d.UnitPrice AS DOUBLE) IS NOT NULL AND
    TRY_CAST(d.Quantity AS DOUBLE) IS NOT NULL

  GROUP BY Year
  ORDER BY Year DESC
")

```

```{r, echo=FALSE}

ccrs_enriched <- ccrs_sales %>%
  mutate(
    `DOR Estimate` = case_when(
      Year == "2022" ~ 1300000000,
      Year == "2023" ~ 900000000,
      Year == "2024" ~ 1100000000,
      Year == "2025" ~ 1200000000,
      TRUE ~ NA_real_
    ),
    Difference = CCRS_Sales - `DOR Estimate`,
    is_2022 = Year == "2022"
  )

# Format and clean for display
ccrs_display <- ccrs_enriched %>%
  mutate(
    `CCRS Sales (No Tax)` = ifelse(
      is_2022,
      cell_spec(scales::dollar(CCRS_Sales), color = "black"),
      cell_spec(scales::dollar(CCRS_Sales), color = "black")
    ),
    `CCRS Sales (With Tax)` = ifelse(
      is_2022,
      cell_spec(scales::dollar(CCRS_Sales_With_Tax), color = "black"),
      cell_spec(scales::dollar(CCRS_Sales_With_Tax), color = "black")
    ),
    `DOR Estimate` = ifelse(
      is.na(`DOR Estimate`),
      "",
      cell_spec(scales::dollar(`DOR Estimate`, accuracy = 1), color = "black")
    ),
    Difference = case_when(
      is.na(Difference) ~ "",
      Difference < 0 ~ cell_spec(
        paste0("(", scales::dollar(abs(Difference), accuracy = 1), ")"),
        color = "red"
      ),
      TRUE ~ cell_spec(scales::dollar(Difference, accuracy = 1), color = "black")
    )
  ) %>%
  select(
    Year,
    `CCRS Sales (No Tax)`,
    `CCRS Sales (With Tax)`,
    `DOR Estimate`,
    Difference
  )


```

```{r, echo=FALSE, include=TRUE}

# Create table
ccrs_display %>%
  kbl(
    escape = FALSE,
    caption = "Comparison of CCRS-reported cannabis sales to Department of Revenue estimates. 
2022 is the only year with a published estimate from the Washington State Auditor ($1.3B). 
We include illustrative estimates for 2023‚Äì2025 based on market maturity and CCRS data. 
Even in 2025, with improved data quality, reported sales remain below 50% of the 2022 benchmark.",
    col.names = c("Year", "CCRS Sales (No Tax)", "With Tax", "DOR Estimate", "Difference"),
    align = "lrrrr"
  ) %>%
  kable_styling(
    full_width = FALSE,
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )

```

<br>

**Outlier Sales Transactions**
```{r, echo=TRUE}

outliers <- dbGetQuery(con, "
  SELECT
    d.SaleDetailId,
    h.LicenseeId,
    strftime(TRY_CAST(h.CreatedDate AS TIMESTAMP), '%Y') AS Year,
    p.InventoryType,
    TRY_CAST(d.UnitPrice AS DOUBLE) AS UnitPrice,
    TRY_CAST(d.Quantity AS DOUBLE) AS Quantity,
    TRY_CAST(d.UnitPrice AS DOUBLE) * TRY_CAST(d.Quantity AS DOUBLE) AS TotalPrice
  FROM sales_detail_all d
  JOIN sale_header_all h 
    ON d.SaleHeaderId = h.SaleHeaderId
  LEFT JOIN inventory_all i 
    ON d.InventoryId = i.InventoryId
  LEFT JOIN product_all p 
    ON i.ProductId = p.ProductId
  WHERE 
    TRY_CAST(d.UnitPrice AS DOUBLE) * TRY_CAST(d.Quantity AS DOUBLE) > 10000 
    OR TRY_CAST(d.UnitPrice AS DOUBLE) > 1000
  ORDER BY TotalPrice DESC
  LIMIT 500
")
```

```{r, echo=FALSE, include=TRUE}


outliers %>%
kbl(digits = 2, format.args = list(big.mark = ",")) %>%
kable_styling(full_width = FALSE)


```

##  Real-Time Limitations
**Inventory Creation to Sale Lag**
```{r, echo=TRUE}

inventory_lag <- dbGetQuery(con, "
  SELECT
    i.InventoryId,
    i.CreatedDate AS InventoryDate,
    MIN(h.SaleDate) AS FirstSaleDate,
    DATEDIFF(
      'day',
      TRY_CAST(i.CreatedDate AS TIMESTAMP),
      MIN(TRY_CAST(h.SaleDate AS TIMESTAMP))
    ) AS LagDays
  FROM inventory_all i
  JOIN sales_detail_all s ON i.InventoryId = s.InventoryId
  JOIN sale_header_all h ON s.SaleHeaderId = h.SaleHeaderId
  WHERE 
    TRY_CAST(i.CreatedDate AS TIMESTAMP) IS NOT NULL AND
    TRY_CAST(h.SaleDate AS TIMESTAMP) IS NOT NULL
  GROUP BY i.InventoryId, i.CreatedDate
 ")
```

```{r, echo=TRUE, include=TRUE}

summary(inventory_lag$LagDays)

```
##  Distribution of Lag Day 
```{r, echo=FALSE, include=TRUE}

# Filter to remove extreme right tail
inventory_lag_filtered <- inventory_lag %>%
  filter(LagDays >= 0 & LagDays <= 550)

# Create ggplot
lag_hist <- ggplot(inventory_lag_filtered, aes(x = LagDays)) +
  geom_histogram(binwidth = 5, fill = "steelblue") +
  labs(
    title = "Distribution of Inventory Lag (Positive Lag Only)",
    x = "Days from Inventory Creation to First Sale",
    y = "Number of Inventory Records",
    caption = "Summary of LagDays (full range): Min = -1041, Q1 = 1, Median = 4, Mean = 20.5, Q3 = 15, Max = 3025.\nPlot shows only positive values up to 550 days to improve interpretability."
  ) +
  theme_minimal()

# Convert to interactive plot
ggplotly(lag_hist)
```

<br>
**Licenses with Sale Date preceding Created Dates (Negative Lag Days)**
```{r, echo=TRUE}
# Query inventory lags with negative values
negative_lag <- dbGetQuery(con, "
  SELECT
    i.InventoryId,
    l.LicenseNumber,
    i.CreatedDate AS CreatedDate,
    MIN(h.SaleDate) AS FirstSaleDate,
    DATEDIFF(
      'day',
      TRY_CAST(i.CreatedDate AS TIMESTAMP),
      MIN(TRY_CAST(h.SaleDate AS TIMESTAMP))
    ) AS LagDays
  FROM inventory_all i
  JOIN sales_detail_all s ON i.InventoryId = s.InventoryId
  JOIN sale_header_all h ON s.SaleHeaderId = h.SaleHeaderId
  JOIN licensee_all l ON i.LicenseeId = l.LicenseeId
  WHERE 
    TRY_CAST(i.CreatedDate AS TIMESTAMP) IS NOT NULL AND
    TRY_CAST(h.SaleDate AS TIMESTAMP) IS NOT NULL
  GROUP BY 
    i.InventoryId, i.CreatedDate, l.LicenseNumber
  HAVING LagDays < 0
  ORDER BY LagDays ASC
  LIMIT 40
")
```

```{r, echo=FALSE, include=TRUE}
# Render table
negative_lag %>%
  mutate(
    LagDays = paste0(LagDays, " days")
  ) %>%
  kbl(caption = "Inventory Records with Negative Lag (Sale Before Inventory Created)") %>%
  kable_styling(full_width = FALSE)
```
The License Information can be added to the table using the above query and add "l.Name AS LicenseeName".  
Here, we protect that personal information. [For additional information, contact us.](mailto:franklin@evergreencannaledger.org) 
<br>

## WSLCB CCRS Compliance  
Let's breakdown by license to see who frequently updates their records: 
```{r, echo=TRUE}

product_update_by_licensee <- dbGetQuery(con, "
  SELECT 
    LicenseeId,
    COUNT(*) AS TotalRecords,
    SUM(CASE 
          WHEN TRY_CAST(UpdatedDate AS TIMESTAMP) > TRY_CAST(CreatedDate AS TIMESTAMP)
          THEN 1 ELSE 0 
        END) AS UpdatedRecords,
    ROUND(100.0 * SUM(CASE 
          WHEN TRY_CAST(UpdatedDate AS TIMESTAMP) > TRY_CAST(CreatedDate AS TIMESTAMP)
          THEN 1 ELSE 0 
        END) / COUNT(*), 1) AS PctUpdated
  FROM product_all
  GROUP BY LicenseeId
  ORDER BY PctUpdated DESC
  LIMIT 100
")
```

```{r, echo=FALSE, include=TRUE}

product_update_by_licensee %>%
kbl() %>%
kable_styling(full_width = FALSE)

```

<br>
Let's see **how long after** records are updated by licensees:
```{r, echo=TRUE}

update_lag <- dbGetQuery(con, "
  SELECT 
    LicenseeId,
    AVG(DATEDIFF('day', TRY_CAST(CreatedDate AS TIMESTAMP), TRY_CAST(UpdatedDate AS TIMESTAMP))) AS AvgLagDays,
    COUNT(*) AS TotalRecords
  FROM product_all
  WHERE 
    TRY_CAST(UpdatedDate AS TIMESTAMP) > TRY_CAST(CreatedDate AS TIMESTAMP)
  GROUP BY LicenseeId
  ORDER BY AvgLagDays DESC
  LIMIT 100
")

```

```{r, echo=FALSE, include=TRUE}

update_lag %>%
kbl() %>%
kable_styling(full_width = FALSE)

```

<br>
The tables above were only snapshots of the full dataset.

At this time, the regulatory is just catching up with enforcing compliance of data submission, but not accuracy, correctness, or precision.  

What's at stake with the lack of data compliance:

+ No accountability of seed-to-sale transactions.
+ WA-produced marijuana can leave the state, which is unlawful.
+ Misguided product claims.
+ Compromised data democracy and reporting for license holders.

This observation is inline with the Office of the State Auditor observations mentioned above. While government regulations and compliance can be burdensome and like a chore to do, it helps level the state cannabis industry to one that is open, understood, and so, resilient to crisis.      

[Feel free to reach out with any questions or request the full report.](mailto:tecl@evergreencannaledger.org)

<br>


