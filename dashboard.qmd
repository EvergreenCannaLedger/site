---
title: "Washington Cannabis Dashboards" 
subtitle: "The Appreciation of Licensees Adopting CCRS Reporting"
format:
  html:
    theme: flatly
    toc: true
    embed-resources: false
    allow-html: true
execute:
  echo: false
  warning: false
  message: false
---

## Number of Licensees (2021-2025)

```{r, echo=FALSE, include=FALSE}

library(tidyverse)
library(DBI)
library(dplyr)
library(lubridate)
library(plotly)
library(arrow)
library(duckdb)
library(fs)
library(glue)
library(kableExtra)
library(scales)
library(DT)

#Clean Slate Function
unregister_all_arrow <- function(con) {
  walk(duckdb_list_arrow(con), ~ {
    duckdb_unregister_arrow(con, .x)
    message("üßπ Unregistered: ", .x)
  })
}

#unregister_all_arrow(con)

# Header cleaner helper function
to_snake <- function(x) {
  x %>%
    tools::file_path_sans_ext() %>%
    str_replace_all("([a-z])([A-Z])", "\\1_\\2") %>%
    str_replace_all("[^[:alnum:]_]", "_") %>%
    str_to_lower()
}

# set paths
base_dir <- "C:/Users/theob/OneDrive/Documents/evergreen-canna-ledger/arrow"
duckdb_path <- file.path(dirname(base_dir), "duckdb_master.duckdb")

# Connect to DuckDB
con <- dbConnect(duckdb::duckdb(), dbdir = duckdb_path, read_only = FALSE)

# Register base files (historical master data)
register_master_parquet <- function(con, base_dir) {
  master_files <- list.files(base_dir, pattern = "\\.parquet$", full.names = TRUE)

  table_names <- tools::file_path_sans_ext(basename(master_files)) %>%
    str_replace_all("([a-z])([A-Z])", "\\1_\\2") %>%
    str_replace_all("[^[:alnum:]_]", "_") %>%
    str_to_lower()

  walk2(table_names, master_files, ~ {
    table_name <- paste0(.x, "_master")
    if (table_name %in% duckdb_list_arrow(con)) {
      duckdb_unregister_arrow(con, table_name)
      message("üßπ Unregistered master: ", table_name)
    }

    dataset <- arrow::open_dataset(.y)
    duckdb_register_arrow(con, table_name, dataset)
    message("üì¶ Registered master: ", table_name)
  })
}

# Register master files safely
register_master_parquet(con, base_dir)

#duckdb::duckdb_list_arrow(con)

#Register new monthly folders (already done before, but include here for completeness)
register_monthly_parquet_to_duckdb <- function(db_path, parquet_folders) {
  con <- dbConnect(duckdb::duckdb(), dbdir = db_path, read_only = FALSE)

  for (folder in parquet_folders) {
    month_label <- basename(folder)
    parquet_files <- list.files(folder, pattern = "\\.parquet$", full.names = TRUE)

    table_names <- tools::file_path_sans_ext(basename(parquet_files)) %>%
      str_replace_all("([a-z])([A-Z])", "\\1_\\2") %>%
      str_replace_all("[^[:alnum:]_]", "_") %>%
      str_to_lower()

    walk2(table_names, parquet_files, ~ {
      table_name <- paste0(.x, "_", month_label)
      if (table_name %in% duckdb_list_arrow(con)) {
        duckdb_unregister_arrow(con, table_name)
        message("üßπ Unregistered: ", table_name)
      }

      dataset <- arrow::open_dataset(.y)
      duckdb_register_arrow(con, table_name, dataset)
      message("üìå Registered monthly: ", table_name)
    })
  }

  return(con)
}

#Register monthly files safely
monthly_dirs <- dir_ls(base_dir, recurse = FALSE, type = "directory")
monthly_arrow_dirs <- monthly_dirs[str_detect(monthly_dirs, "arrow_[a-z]+2025")]
register_monthly_parquet_to_duckdb(duckdb_path, monthly_arrow_dirs)

# Create unified views (master + monthly)
create_combined_view <- function(con, base_name) {
  tables <- duckdb_list_arrow(con)
  relevant_tables <- tables[str_detect(tables, paste0("^", base_name, "_(master|arrow_.*2025)"))]

  if (length(relevant_tables) == 0) {
    message("‚ö†Ô∏è No tables found for ", base_name)
    return(invisible(NULL))
  }

  # Get Arrow schema columns for each table
  column_lists <- map(relevant_tables, ~ {
  cols <- names(dbGetQuery(con, glue::glue("SELECT * FROM \"{.x}\" LIMIT 0")))
  tibble(table = .x, column = cols)
}) %>% bind_rows()

  # Keep only columns common to all tables
  common_columns <- column_lists %>%
    group_by(column) %>%
    summarise(n_tables = n_distinct(table), .groups = "drop") %>%
    filter(n_tables == length(relevant_tables)) %>%
    pull(column)

  if (length(common_columns) == 0) {
    message("‚ùå No common columns found across tables for ", base_name)
    return(invisible(NULL))
  }

  # (Optional) Log any dropped columns
  all_cols <- column_lists %>% distinct(column)
  dropped_cols <- setdiff(all_cols$column, common_columns)
  if (length(dropped_cols)) {
    message("‚ö†Ô∏è Dropping columns not in all tables for ", base_name, ": ", paste(dropped_cols, collapse = ", "))
  }

  # Build UNION ALL
  union_parts <- map_chr(relevant_tables, ~ {
    cols <- paste(common_columns, collapse = ", ")
    glue::glue("SELECT {cols} FROM \"{.x}\"")  # quote in case of special chars
  })

  union_sql <- glue::glue("
    CREATE OR REPLACE VIEW {base_name}_all AS
    {paste(union_parts, collapse = '\nUNION ALL\n')}
  ")

  dbExecute(con, union_sql)
  message("‚úÖ Created view: ", base_name, "_all with ", length(relevant_tables), " parts.")
}

views_to_create <- c(
  "sales_detail", "sale_header", "inventory", "product", "lab_result",
  "areas", "licensee", "plant", "strains", "contacts"
)

walk(views_to_create, ~ create_combined_view(con, .x))

# Materialize the table for downstream visualization
dbExecute(con, "
  CREATE OR REPLACE TEMP TABLE sale_header_temp AS
  SELECT * FROM sale_header_all
")

dbExecute(con, "
  CREATE OR REPLACE TEMP TABLE sales_detail_temp AS
  SELECT * FROM sales_detail_all
")


```

```{r, include=FALSE}

# Monthly Sales
monthly_sales <- dbGetQuery(con, "
WITH base AS (
SELECT
sh.LicenseeId,
DATE_TRUNC('month', CAST(sh.SaleDate AS DATE)) AS Month,
CAST(sd.Quantity AS DOUBLE) * CAST(sd.UnitPrice AS DOUBLE) +
CAST(sd.SalesTax AS DOUBLE) + CAST(sd.OtherTax AS DOUBLE) AS Revenue
FROM sales_detail_all sd
JOIN sale_header_all sh ON sd.SaleHeaderId = sh.SaleHeaderId
WHERE DATE(CAST(sh.SaleDate AS DATE)) BETWEEN '2021-12-01' AND '2025-11-03'
AND CAST(sd.UnitPrice AS DOUBLE) < 200
),
grouped AS (
SELECT
Month,
LicenseeId,
SUM(Revenue) AS TotalRevenue
FROM base
GROUP BY Month, LicenseeId
),
licensee_counts AS (
SELECT
Month,
COUNT(DISTINCT LicenseeId) AS LicenseeCount
FROM grouped
GROUP BY Month
ORDER BY Month
)
SELECT * FROM licensee_counts
")

```

**Monthly Licensee Participation**

```{r}
# Convert Month to date type

monthly_sales <- monthly_sales %>%
mutate(Month = as.Date(Month))

# Plotly bar chart
plot_ly(
data = monthly_sales,
x = ~Month,
y = ~LicenseeCount,
type = "bar",
marker = list(color = "#2C7BB6")
) %>%
layout(
title = "Number of Licensees Reporting Monthly (Dec 2021 - Nov 2025)",
xaxis = list(title = "Month"),
yaxis = list(title = "Licensee Count"),
hovermode = "x unified"
)

```

## Product Category Growth Over Time
**Double click on a name in legend to isolate that field**
**Double click again to reset and view all, repeat**
```{r}

product_growth <- dbGetQuery(con, "
SELECT
DATE_TRUNC('month', CAST(sh.SaleDate AS DATE)) AS Month,
p.InventoryType,
SUM(CAST(sd.Quantity AS DOUBLE)) AS UnitsSold
FROM sales_detail_all sd
JOIN sale_header_all sh ON sd.SaleHeaderId = sh.SaleHeaderId
JOIN inventory_all i ON sd.InventoryId = i.InventoryId
JOIN product_all p ON i.ProductId = p.ProductId
WHERE sh.SaleDate IS NOT NULL
GROUP BY Month, p.InventoryType
ORDER BY Month
")
```

```{r}

product_growth <- product_growth %>% mutate(Month = as.Date(Month))

plot_ly(
data = product_growth,
x = ~Month,
y = ~UnitsSold,
color = ~InventoryType,
type = 'scatter',
mode = 'lines+markers'
) %>%
layout(
title = "Product Category Growth Over Time",
xaxis = list(title = "Month"),
yaxis = list(title = "Units Sold"),
legend = list(orientation = 'h', x = 0.1, y = -0.2)
)

```

## Total Revenue

```{r, include=FALSE}

retail_wholesale <- dbGetQuery(con, "
  SELECT 
    DATE_TRUNC('month', CAST(sh.SaleDate AS DATE)) AS Month,
    sh.SaleType,
    SUM(CAST(sd.Quantity AS DOUBLE) * CAST(sd.UnitPrice AS DOUBLE)) AS Revenue
  FROM sales_detail_temp sd
  JOIN sale_header_temp sh ON sd.SaleHeaderId = sh.SaleHeaderId
  WHERE sh.SaleType IN ('Retail', 'Wholesale')
  GROUP BY Month, sh.SaleType
  ORDER BY Month
")


```

```{r}

retail_wholesale <- retail_wholesale %>% mutate(Month = as.Date(Month))

plot_ly(retail_wholesale, x = ~Month, y = ~Revenue, color = ~SaleType, type = "bar") %>%
  layout(
    barmode = "group",
    title = "Total Reported Revenue",
    xaxis = list(title = "Month"),
    yaxis = list(title = "Revenue ($)", tickformat = "$,.0f"),
    legend = list(title = list(text = "Sale Type")),
    hovermode = "x unified"
  )

```

## Regional or Business-Level Insights (City Location)

```{r, include=FALSE}

regional_sales <- dbGetQuery(con, "
SELECT
l.City,
SUM(CAST(sd.Quantity AS DOUBLE) * CAST(sd.UnitPrice AS DOUBLE)) AS Revenue
FROM sales_detail_all sd
JOIN sale_header_all sh ON sd.SaleHeaderId = sh.SaleHeaderId
JOIN licensee_all l ON sh.LicenseeId = l.LicenseeId
WHERE sh.SaleDate IS NOT NULL AND l.City IS NOT NULL
GROUP BY l.City
ORDER BY Revenue DESC
LIMIT 10
")

```

```{r}
plot_ly(
  data = regional_sales,
  x = ~reorder(City, Revenue),  # Fixed the reorder logic
  y = ~Revenue,
  type = 'bar',
  orientation = 'v',
  marker = list(color = "darkgreen")
) %>%
layout(
  title = "Top Business Licensee Cities by Revenue",
  xaxis = list(title = "City"),
  yaxis = list(
    title = "Revenue",
    tickformat = "$,.2f"  # Dollar formatting
  ),
  margin = list(b = 100)
)

```
## Product Category Trends (2021‚Äì2024)
```{r, warning=FALSE}

unregister_all_arrow(con)

if (exists("con")) 
  try(DBI::dbDisconnect(conn = con), silent = TRUE)

source("R_scripts/connect_duckdb_readonly.R")

# Query category-level trends
category_summary <- dbGetQuery(con, "
  WITH sales_base AS (
    SELECT 
      sd.SaleDetailId,
      sh.SaleDate,
      pr.InventoryType,
      CAST(sd.Quantity AS DOUBLE) AS Quantity,
      CAST(sd.UnitPrice AS DOUBLE) AS UnitPrice,
      CAST(sd.Discount AS DOUBLE) AS Discount
    FROM SalesDetail_all sd
    JOIN SaleHeader_all sh ON sd.SaleHeaderId = sh.SaleHeaderId
    JOIN Inventory_all inv ON sd.InventoryId = inv.InventoryId
    JOIN Product_all pr ON inv.ProductId = pr.ProductId
    WHERE (sd.IsDeleted IS NULL OR sd.IsDeleted NOT IN ('TRUE', 'true'))
      AND (sh.IsDeleted IS NULL OR sh.IsDeleted NOT IN ('TRUE', 'true'))
      AND (inv.IsDeleted IS NULL OR inv.IsDeleted NOT IN ('TRUE', 'true'))
      AND (pr.IsDeleted IS NULL OR pr.IsDeleted NOT IN ('TRUE', 'true'))
      AND CAST(sd.UnitPrice AS DOUBLE) < 200
  )

  SELECT 
    EXTRACT(YEAR FROM DATE(SaleDate)) AS Year,
    InventoryType,
    SUM(Quantity) AS UnitsSold,
    ROUND(SUM(Quantity * UnitPrice), 2) AS Revenue,
    ROUND(AVG(UnitPrice), 2) AS AvgUnitPrice,
    ROUND(MEDIAN(UnitPrice), 2) AS MedianUnitPrice
  FROM sales_base
  GROUP BY 1, 2
  ORDER BY Year, Revenue DESC
")

# Format for publication
category_summary %>%
  filter(
    !InventoryType %in% c(
      "Flower Unlotted", "Other Material Lot", "Other Material Unlotted",
      "Plant", "Sample Jar", "Seed", "Waste"
    )
  ) %>%
  mutate(
    Revenue = dollar(Revenue),
    AvgUnitPrice = dollar(AvgUnitPrice),
    MedianUnitPrice = dollar(MedianUnitPrice),
    UnitsSold = comma(UnitsSold)
  ) %>%
  rename(
    Year = Year,
    Category = InventoryType,
    `Units Sold` = UnitsSold,
    `Total Revenue` = Revenue,
    `Avg. Unit Price` = AvgUnitPrice,
    `Median Unit Price` = MedianUnitPrice
  ) %>%
  arrange(Category, Year) %>%
  datatable(
    caption = htmltools::tags$caption(
      style = 'caption-side: bottom; text-align: left;',
      'Product Category Trends (2021‚Äì2024)'
    ),
    filter = "top",          # üëà adds column filters
    rownames = FALSE,
    options = list(
      pageLength = 20,       # üëà show 20 rows at a time
      lengthMenu = c(10, 20, 50, 100),
      autoWidth = TRUE,
      dom = "lfrtip"         # length, filter, table, pagination
    )
  )
```


<br>

:::{.text-center}
[Make a dashboard request you want to see live in this Dashboard page.](mailto:tecl@evergreencannaledger.org)
:::